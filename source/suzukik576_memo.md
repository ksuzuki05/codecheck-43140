## 注意

- このプロジェクトは [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html) に沿ってコーディングされていますが、以下の点は、普段のコーディングスタイルに合わせています。
    - インデントは空白 2 文字ではなく 4 文字を採用
    - ワイルドカードインポートは非推奨とされているが、テストコードに限り、利便性を重視してスタティックインポートにはワイルドカードを使用
    - テストケースには日本語を使用
- 問題の中で参考文献として挙げられている [REST入門 基礎知識](https://qiita.com/TakahiRoyte/items/949f4e88caecb02119aa) に従うと、レシピ作成に成功した場合の返すべきステータスコードは `201 Created` だと考えられますが、codecheck が提供するテストコードでは `200 OK` を返すよう求められていたりと、一部 RESTful にそぐわないと考えられる実装もあります。原則、codecheck 提供のテストコードが通ることを最優先として仕様を決定しています。
- ホスティングサービスには heroku を使用しました。はじめに codecheck から提供される sql には `on update` など、MySQL 特有の文法が使われていましたが、heroku との親和性を考慮し、postgreSQL の文法に書き換えて使用しています。`on update` など一部の機能は失われますが、アプリ側で担保することにしています。

## DI の利用について
（ ../answer.md ではなくこちらに記述します。）

- 本プロジェクトでは、Spring のアノテーションである `@Autowired, @Repository, @Service` を用いて DI を実現しています。
- アプリケーション層を担当する `****RestController` クラスは、サービス層を担当するクラスである `RecipesServiceImpl` を DI によって使用し、この `RecipesServiceImpl` はデータアクセス層を担当する DAO クラスである `RecipesRepositoryImpl` を DI によって使用しています。
- DI を使用しない場合、たとえばサービスクラスでは、データアクセスクラスを `new` 演算子によってインスタンス化する必要があります。すると、以下のような問題が発生します。
    - サービスクラスがデータアクセスクラスの実装に依存することになり、DB の変更などでデータアクセスクラスに改修が入るとサービスクラスにも改修が必要となる場合がある。
    - サービスクラスとデータアクセスクラスが密結合となり、サービスクラスの単体テストを行いづらくなる。データアクセスクラスをモックにしてテストしたい場合、サービスクラスにはモックオブジェクトに置き換えるメソッドを別途用意する必要が出てくる。
    - サービスや DAO のような Singleton として実装したいコンポーネントは、FactoryMethod や Singleton パターンを駆使して実装する必要がある。
- これに対し、ドメインクラスはデータアクセス層が提供するインタフェースにのみ依存するように実装し、DI によって実装クラスのインスタンスを注入することで、上記の問題点は以下のように解決できます。
    - データアクセスクラスの実装が変更されても、提供するインタフェースさえ変わらなければドメインクラスには影響がない
    - Mockito などのライブラリを使うことで、データアクセスクラスのモックオブジェクト化が容易に行えるので、単体テストがしやすい
    - インスタンス化は（デフォルトで）１回、DI コンテナが行ってくれるので、特に意識することなく Singleton を実現できる。
- このように、インタフェースベースのコンポーネント化を意識した設計をすることで、「部品化」の利点を享受できるようになり、変更や拡張に強いアプリケーションを作ることができます。